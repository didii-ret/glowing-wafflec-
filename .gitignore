# Prerequisites
*.d

# Compiled Object files
*.slo
*.lo
*.o
*.obj

# Precompiled Headers
*.gch
*.pch

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.app
5-2：
template<class T>
void changelengthID(T*& a, int oldLength,int newLength)
{
if (newLength < 0)
  throw illegalParameterValue("new length must be >= 0");
  
  T* temp + new T[newLength];            //新数组
  int number = min(oldLength ,newLength);//需要复制的元素个数
  copy（a, a + number, temp);
  delete [] a;                           //释放老数组的内存空间
  a = temp;
 }
 5-3
 template<class T>
 Class arrayList : public linearList<T>
 {
    public:
    //构造函数，复制构造函数和析构函数
    arrayList (int initialCapacity = 10);
    arrayList (const arrayList <T> &);
    ~arrayList () {delete [] element:}\
    //ADT方法
    bool empty() const {return listSize == 0;}
    int size() const {return listSize;}
    T& get(int theIndex) const;
    int indexof(const T& theElement) const;
    void erase(int theIndex);
    void insert(int theIndex, const T& theElement);
    void output(ostream& out) const;
    
    //其他方法
    int capacity () const {return arrayLength;}
    
  protected:
    void checkIndex(int theIndex) const;
        //若索引theIndex 无效，则抛出异常
    T* element;                     //储存线性表元素的一维数组
    int arrayLength;                //一维数组的容量
    int listSize;                   //线性表的元素个数

第五章
//arraList类.h
#ifndef ARRAYLIST_H
#define ARRAYLIST_H
#include<iostream>
template<class T>
class arrayList :public linearList<T>
{
public:
	//构造函数、复制构造函数和析构函数
	arrayList(int initialCapacity=10);
	arrayList(const arrayList<T>&);
	~arrayList() { delete[] element; }
	
	//ADT方法
	bool empty() const { return listSize == 0; }
	int size()const { retuen listSize; }
	T&get(int theIndex) const;
	int indexOf(const T& theElement)const;
	void erase(int theIndex);
	void insert(int theIndex, const T & theElement);
	void output(ostream& out) const;

	//其他方法
	int capacity() const { return arrayLength; }

protected:
	void checkIndex(int theIndex) const;
	//若索引theIndex无效，则抛出异常
	T* element;//存储线性元素的一维数组
	int arrayLength;//一维数组的容量
	int listSize;//线性表的元素个数
};
#endif

//linearList.h
#ifndef lINEARLIST_H
#define lINEARLIST_H
#include<iostream>
#include<ostream>
template<class T>
class linearList
{
public:
	virtual ~linearList() {};
	virtual bool empty()const = 0;
	//返回ture，当且仅当线性表为空。
	virtual int size()const = 0;
	//返回线性表的元素个数。
	virtual T& get(int theIndex)const = 0;
	//返回索引为theIndex的元素。
	virtual int indexOf(const T& theElement)const = 0;
	//返回元素theElement第一次出现时的索引
	virtual void erase(int theIndex) = 0;
	//删除索引为theIndex的元素。
	virtual void insert(int theIndex, const T& theElement) = 0;
	//把theElement插入线性表中索引为theIndex的位置上。
	virtual void output(ostream& out)const = 0;
	//把线性表插入输出流out
};
// TODO: 添加要在此处预编译的标头

#endif


//arrayList.cpp
#include "linearList.h"
#include "arrayList.h"
#include<iostream>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>
#include<iterator>
using namespace std;

template<class T>
arrayList<T>::arrayList(int initialCapacity)
{
	if (initialCapacity < 1)
	{
		ostringstream s;
		s << "Initial capacity = " << initialCapacity << "Must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = initialCapacity;
	element = new T[arrayLength];
	listSize = 0;
}

template<class T>
arrayList<T>::arrayList(const arrayList<T>& theList)
{
	//复制构造函数
	arrayLength = theList.arrayLength;
	listSize = theList.listSize;
	element = new T[arrayLength];
	copy(theList.element, theList.element + listSize, element);
}

template<class T>
void arrayList<T>::checkIndex(int theIndex) const
{
	//确定索引theIndex再0和listSize - 1之间
	if (theIndex < 0 || theIndex >= listSize)
	{
		ostringstream s;
		s << "index = " << theIndex << "size = " << listSize;
		throw illegalTndex(s.str());
	}
}

template<class T>
T& arrayList<T>::get(int theIndex) const
{
	//返回索引为theIndex的元素
	//若此元素不存在，则抛出异常
	checkIndex(theIndex);
	return element[theIndex];
}

template<class T>
int arrayList<T>::indexOf(const T& theElement)const
{
	//返回元素theElement第一次出现时的索引
	//若元素不存在，则返回-1

	//查找元素theElement
	int theElement = (int)(find(element, element + listSize, theElement) - element);

	//确定元素theElement是否找得到
	if (theIndex == listSize)
		//没有找到
		return -1;
	else return theIndex;
}

template<class T>
void arrayList<T>::erase(int theIndex)
{
	//删除其索引为theIndex的元素
	//如果该元素不存在，则抛出异常illegalIndex
	checkIndex(theIndex);

	//有效索引，移动其索引大雨theIndex的元素
	copy(element + theIndex + 1, element_listSize, element + theIndex);
	element[== listSize].~T();//调用析构函数
}

template<class T>
void arrayList<T>::insert(int theIndex, const T& theElement)
{
	
		//在索引theIndex处插入元素theElement
		if (theIndex < 0 || theIndex > listSize)
		{
			//无效索引
			ostringstream s;
			s << "index = " << theIndex << "Size = " << listSize;
			throw illegalIndex(s.str());
		}

		//有效索引。确定数组是否已满
		if (listSize == arrayLength)
		{
			//数组空间已满，数组长度倍增
			changeLength1D(element, arrayLength, 2 * arrayLength);
			arrayLength *= 2;
		}
		//把元素享有移动一个位置
		copy_backward(element + theIndex, element + listSize, element + listSize + 1);

		element[theIndex] = theElement;
		listSize++;
}

template<class T>
void arrayList<T>::output(ostream & cout ) const
{
	//把线性表插入输出流
	copy(element, element + listSize, ostream_iterator<T>(cout, " "));

}

template<class T>

//重载<<
template <class T>
ostream& operator <<(ostream& out, const arrayList<T>& x)
{
	x.output(out);
	return out;
}


5.12~5.14
//vectorList.h
#ifndef vectorList_
#define vectorList_

#include<iostream>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>
#include<iterator>
#include "linearList.h"
#include "myExceptions.h"

using namespace std;

template<class T>
class vectorList : public linearList<T> 
{
   public:
      vectorList(int initialCapacity = 10);
      vectorList(const vectorList<T>&);
      ~vectorList() {delete element;}
      
      bool empty() const {return element->empty();}
      int size() const {return (int) element->size();}
      T& get(int theIndex) const;
      int indexOf(const T& theElement) const;
      void erase(int theIndex);
      void insert(int theIndex, const T& theElement);
      void output(ostream& out) const;

      int capacity() const {return (int) element->capacity();}
      
      typedef typename vector<T>::iterator iterator;
      iterator begin() {return element->begin();}
      iterator end() {return element->end();}

   protected: 
      void checkIndex(int theIndex) const;
      vector<T>* element;  
};

//vectorList.cpp
template<class T>
vectorList<T>::vectorList(int initialCapacity)
{
   if (initialCapacity < 1)
   {ostringstream s;
    s << "Initial capacity = " << initialCapacity << " Must be > 0";
    throw illegalParameterValue(s.str());
   }

   element = new vector<T>;
   element->reserve(initialCapacity);
}

template<class T>
vectorList<T>::vectorList(const vectorList<T>& theList)
{
   element = new vector<T>(*theList.element);
}

template<class T>
void vectorList<T>::checkIndex(int theIndex) const
{
   if (theIndex < 0 || theIndex >= size())
   {ostringstream s;
    s << "index = " << theIndex << " size = " << size();
    throw illegalIndex(s.str());
   }

}

template<class T>
T& vectorList<T>::get(int theIndex) const
{// Return element whose index is theIndex.
 // Throw illegalIndex exception if no such element.
   checkIndex(theIndex);
   return (*element)[theIndex];
}

template<class T>
int vectorList<T>::indexOf(const T& theElement) const
{
   int theIndex = (int) (find(element->begin(), element->end(),
                         theElement)
                         - element->begin());

 
   if (theIndex == size())
  
     return -1;
   else return theIndex;
 }

template<class T>
void vectorList<T>::erase(int theIndex)
{
   checkIndex(theIndex);
   element->erase(begin() + theIndex);
}

template<class T>
void vectorList<T>::insert(int theIndex, const T& theElement)
{
   if (theIndex < 0 || theIndex > size())
   {
      ostringstream s;
      s << "index = " << theIndex << " size = " << size();
      throw illegalIndex(s.str());
   }

   element->insert(element->begin() + theIndex, theElement);
}

template<class T>
void vectorList<T>::output(ostream& out) const
{
   copy(element->begin(), element->end(), ostream_iterator<T>(cout, "  "));
}


template <class T>
ostream& operator<<(ostream& out, const vectorList<T>& x)
   {x.output(out); return out;}

#endif

//main.cpp
#include<iostream>
#include<numeric>
#include<algorithm>   
#include<functional>  
#include "linearList.h"
#include "vectorList.h"

using namespace std;

int main()
{

   linearList<double> *x = new vectorList<double>(20);
   vectorList<int> y(2), z;

   cout << "Capacity of x, y and z = "
        << ((vectorList<double>*) x)->capacity() << ", "
        << y.capacity() << ", "
        << z.capacity() << endl;


   cout << "Initial size of x, y, and z = "
        << x->size() << ", "
        << y.size() << ", "
        << z.size() << endl;

   if (x->empty()) cout << "x is empty" << endl;
   else cout << "x is not empty" << endl;
   if (y.empty()) cout << "y is empty" << endl;
   else cout << "y is not empty" << endl;

   y.insert(0, 2);
   y.insert(1, 6);
   y.insert(0, 1);
   y.insert(2, 4);
   y.insert(3, 5);
   y.insert(2, 3);
   cout << "Inserted 6 integers, list y should be 1 2 3 4 5 6" << endl;
   cout << "Size of y = " << y.size() << endl;
   cout << "Capacity of y = " << y.capacity() << endl;
   if (y.empty()) cout << "y is empty" << endl;
   else cout << "y is not empty" << endl;
   y.output(cout);
   cout << endl << "Testing overloaded <<" << endl;
   cout << y << endl;

   int index = y.indexOf(4);
   if (index < 0) cout << "4 not found" << endl;
   else cout << "The index of 4 is " << index << endl;

   index = y.indexOf(7);
   if (index < 0) cout << "7 not found" << endl;
   else cout << "The index of 7 is " << index << endl;
   
   cout << "Element with index 0 is " << y.get(0) << endl;
   cout << "Element with index 3 is " << y.get(3) << endl;


   y.erase(1);
   cout << "Element 1 erased" << endl;
   cout << "The list is "  << y << endl;
   y.erase(2);
   cout << "Element 2 erased" << endl;
   cout << "The list is "  << y << endl;

   cout << "Size of y = " << y.size() << endl;
   cout << "Capacity of y = " << y.capacity() << endl;
   if (y.empty()) cout << "y is empty" << endl;
   else cout << "y is not empty" << endl;

   try {y.insert(-3, 0);}
   catch (illegalIndex e)
   {
      cout << "Illegal index exception" << endl;
      cout << "Insert index must be between 0 and list size" << endl;
      e.outputMessage();
   }

   vectorList<int> w(y);
   y.erase(0);
   y.erase(0);
   cout << "w should be old y, new y has first 2 elements removed" << endl;
   cout << "w is " << w << endl;
   cout << "y is " << y << endl;
   
   y.insert(0,4);
   y.insert(0,5);
   y.insert(0,6);
   y.insert(0,7);
   cout << "y is " << y << endl;

   cout << "Ouput using forward iterators pre and post ++" << endl;
   for (vectorList<int>::iterator i = y.begin();
        i != y.end(); i++)
      cout << *i << "  ";
   cout << endl;
   for (vectorList<int>::iterator i = y.begin();
        i != y.end(); ++i)
      cout << *i << "  ";
   cout << endl;

   cout << "Ouput using backward iterators pre and post --" << endl;
   for (vectorList<int>::iterator i = y.end();
        i != y.begin(); cout << *(--i) << "  ");
   cout << endl;
   for (vectorList<int>::iterator i = y.end();
        i != y.begin();)
      {i--; cout << *i << "  "; *i += 1;} 
   cout << endl;
   cout << "Incremented by 1 list is " << y << endl;

   reverse(y.begin(), y.end());
   cout << "The reversed list is " << y << endl;
   int sum = accumulate(y.begin(), y.end(), 0);
   cout << "The sum of the elements is " << sum << endl;
   sort(y.begin(), y.end());
   cout << "The sorted list is " << y << endl;
   sort(y.begin(), y.end(), greater<int>());
   cout << "The list is descending order is " << y << endl;
   return 0;
}








数据结构算法与应用
//6.1chainNode结构
// chain node

#ifndef chainNode_
#define chainNode_

template <class T>
struct chainNode 
{
   T element;
   chainNode<T> *next;

   chainNode() {}
   chainNode(const T& element)
      {this->element = element;}
   chainNode(const T& element, chainNode<T>* next)
      {this->element = element;
       this->next = next;}
};

#endif

//6.2~6.7
//chain.h
#ifndef CHAIN_H
#define CHAIN_H

#include<iostream>
#include<sstream>
#include<string>
#include "linearList.h"
#include "chainNode.h"

using namespace std;

class linkedDigraph;
template <class T> class linkedWDigraph;

template<class T>
class chain : public linearList<T> 
{
   friend linkedDigraph;
   friend linkedWDigraph<int>;
   friend linkedWDigraph<float>;
   friend linkedWDigraph<double>;
   public:
      chain(int initialCapacity = 10);
      chain(const chain<T>&);
      ~chain();

      bool empty() const {return listSize == 0;}
      int size() const {return listSize;}
      T& get(int theIndex) const;
      int indexOf(const T& theElement) const;
      void erase(int theIndex);
      void insert(int theIndex, const T& theElement);
      void output(ostream& out) const;

   protected:
      void checkIndex(int theIndex) const;

      chainNode<T>* firstNode;  
      int listSize;         
};

//chain.cpp
#include<iostream>
#include<sstream>
#include<string>
#include "linearList.h"
#include "chainNode.h"
#include "chain.h"
template<class T>
chain<T>::chain(int initialCapacity)
{
   if (initialCapacity < 1)
   {ostringstream s;
    s << "Initial capacity = " << initialCapacity << " Must be > 0";
    throw illegalParameterValue(s.str());
   }
   firstNode = NULL;
   listSize = 0;
}

template<class T>
chain<T>::chain(const chain<T>& theList)
{
   listSize = theList.listSize;

   if (listSize == 0)
   {
      firstNode = NULL;
      return;
   }

   
   chainNode<T>* sourceNode = theList.firstNode;
                  
   firstNode = new chainNode<T>(sourceNode->element);
                    
   sourceNode = sourceNode->next;
   chainNode<T>* targetNode = firstNode;
                      while (sourceNode != NULL)
   {
      targetNode->next = new chainNode<T>(sourceNode->element);
      targetNode = targetNode->next;
      sourceNode = sourceNode->next;
   }
   targetNode->next = NULL; // end the chain
}

template<class T>
chain<T>::~chain()
{
   while (firstNode != NULL)
   {// delete firstNode
      chainNode<T>* nextNode = firstNode->next;
      delete firstNode;
      firstNode = nextNode;
   }
}

template<class T>
void chain<T>::checkIndex(int theIndex) const
{
   if (theIndex < 0 || theIndex >= listSize)
   {ostringstream s;
    s << "index = " << theIndex << " size = " << listSize;
    throw illegalIndex(s.str());
   }

}

template<class T>
T& chain<T>::get(int theIndex) const
{
   checkIndex(theIndex);

  
   chainNode<T>* currentNode = firstNode;
   for (int i = 0; i < theIndex; i++)
      currentNode = currentNode->next;

   return currentNode->element;
}

template<class T>
int chain<T>::indexOf(const T& theElement) const
{
   chainNode<T>* currentNode = firstNode;
   int index = 0;  // index of currentNode
   while (currentNode != NULL && 
          currentNode->element != theElement)
   {
      // move to next node
      currentNode = currentNode->next;
      index++;
   }

   if (currentNode == NULL)
      return -1;
   else
      return index;
}

template<class T>
void chain<T>::erase(int theIndex)
{
   checkIndex(theIndex);

   // valid index, locate node with element to delete
   chainNode<T>* deleteNode;
   if (theIndex == 0)
   {// remove first node from chain
      deleteNode = firstNode;
      firstNode = firstNode->next;
   }
   else 
   {  // use p to get to predecessor of desired node
      chainNode<T>* p = firstNode;
      for (int i = 0; i < theIndex - 1; i++)
         p = p->next;
   
      deleteNode = p->next;
      p->next = p->next->next; // remove deleteNode from chain
   }
   listSize--;
   delete deleteNode;
}

template<class T>
void chain<T>::insert(int theIndex, const T& theElement)
{
   if (theIndex < 0 || theIndex > listSize)
   {// invalid index
      ostringstream s;
      s << "index = " << theIndex << " size = " << listSize;
      throw illegalIndex(s.str());
   }

   if (theIndex == 0)

      firstNode = new chainNode<T>(theElement, firstNode);
   else
   { 
      chainNode<T>* p = firstNode;
      for (int i = 0; i < theIndex - 1; i++)
         p = p->next;
   
      // insert after p
      p->next = new chainNode<T>(theElement, p->next);
   }
   listSize++;
}

template<class T>
void chain<T>::output(ostream& out) const
{
   for (chainNode<T>* currentNode = firstNode;
                      currentNode != NULL;
                      currentNode = currentNode->next)
      out << currentNode->element << "  ";
}

// overload <<
template <class T>
ostream& operator<<(ostream& out, const chain<T>& x)
   {x.output(out); return out;}

#endif

//6.1.5
//extendedLinearList.h
#ifndef extendedLinearList_
#define extendedLinearList_
#include <iostream>
#include "linearList.h"

using namespace std;

template<class T>
class extendedLinearList : linearList<T> 
{
   public:
      virtual ~extendedLinearList() {}
      virtual void clear() = 0;
                  // empty the list
      virtual void push_back(const T& theElement) = 0;
                  // insert theElement at end of list
};
#endif

//myExceptions.h
#ifndef myExceptions_
#define myExceptions_
#include <string>

using namespace std;

class illegalParameterValue 
{
   public:
      illegalParameterValue(string theMessage = "Illegal parameter value")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// illegal input data
class illegalInputData 
{
   public:
      illegalInputData(string theMessage = "Illegal data input")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// illegal index
class illegalIndex 
{
   public:
      illegalIndex(string theMessage = "Illegal index")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// matrix index out of bounds
class matrixIndexOutOfBounds 
{
   public:
      matrixIndexOutOfBounds
            (string theMessage = "Matrix index out of bounds")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// matrix size mismatch
class matrixSizeMismatch 
{
   public:
      matrixSizeMismatch(string theMessage = 
                   "The size of the two matrics doesn't match")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// stack is empty
class stackEmpty
{
   public:
      stackEmpty(string theMessage = 
                   "Invalid operation on empty stack")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// queue is empty
class queueEmpty
{
   public:
      queueEmpty(string theMessage = 
                   "Invalid operation on empty queue")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};


class hashTableFull
{
   public:
      hashTableFull(string theMessage = 
                   "The hash table is full")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};


class undefinedEdgeWeight
{
   public:
      undefinedEdgeWeight(string theMessage = 
                   "No edge weights defined")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};

// method undefined
class undefinedMethod
{
   public:
      undefinedMethod(string theMessage = 
                   "This method is undefined")
            {message = theMessage;}
      void outputMessage() {cout << message << endl;}
   private:
      string message;
};
#endif

//extendedChain.h
#ifndef extendedChain_
#define extendedChain_

#include <iostream>
#include <sstream>
#include <string>
#include "extendedLinearList.h"
#include "chainWithIterator.h"
#include "myExceptions.h"

using namespace std;

template<class T>
class extendedChain : public extendedLinearList<T>, public chain<T> 
{
   public:
      // constructor and copy constructor
      extendedChain(int initialCapacity = 10) :
         chain<T>(initialCapacity) {}
      extendedChain(const extendedChain<T>& c) :
         chain<T>(c) {}

      // ADT methods
      bool empty() const {return listSize == 0;}
      int size() const {return listSize;}
      T& get(int theIndex) const
         {return chain<T>::get(theIndex);}
      int indexOf(const T& theElement) const
         {return chain<T>::indexOf(theElement);}
      void erase(int theIndex);
      void insert(int theIndex, const T& theElement);
      void clear()
         {// Delete all nodes in chain.
            while (firstNode != NULL)
            {// delete firstNode
               chainNode<T>* nextNode = firstNode->next;
               delete firstNode;
               firstNode = nextNode;
            }
            listSize = 0;
         }
      void push_back(const T& theElement);
      void output(ostream& out) const
         {chain<T>::output(out);}

      // additional method
      void zero()
         {firstNode = NULL; listSize = 0;}
      
   protected:
      chainNode<T>* lastNode;  // pointer to last node in chain
};

//extendChain.cpp
#include <iostream>
#include <sstream>
#include <string>
#include "extendedChain.h"
#include "extendedLinearList.h"
#include "chainWithIterator.h"
#include "myExceptions.h"
template<class T>
void extendedChain<T>::erase(int theIndex)
{// Delete the element whose index is theIndex.
 // Throw illegalIndex exception if no such element.
   checkIndex(theIndex);

   // valid index, locate node with element to delete
   chainNode<T>* deleteNode;
   if (theIndex == 0)
   {// remove first node from chain
      deleteNode = firstNode;
      firstNode = firstNode->next;
   }
   else 
   {  // use p to get to predecessor of desired node
      chainNode<T>* p = firstNode;
      for (int i = 0; i < theIndex - 1; i++)
         p = p->next;
   
      deleteNode = p->next;
      p->next = p->next->next; // remove deleteNode from chain
      if (deleteNode == lastNode)
         lastNode = p;
   }
   listSize--;
   delete deleteNode;
}

template<class T>
void extendedChain<T>::insert(int theIndex, const T& theElement)
{// Insert theElement so that its index is theIndex.
   if (theIndex < 0 || theIndex > listSize)
   {// invalid index
      ostringstream s;
      s << "index = " << theIndex << " size = " << listSize;
      throw illegalIndex(s.str());
   }

   if (theIndex == 0)
      {// insert at front
         firstNode = new chainNode<T>(theElement, firstNode);
         if (listSize == 0)
            lastNode = firstNode;
      }
   else
   {  // find predecessor of new element
      chainNode<T>* p = firstNode;
      for (int i = 0; i < theIndex - 1; i++)
         p = p->next;
   
      // insert after p
      p->next = new chainNode<T>(theElement, p->next);
      if (listSize == theIndex)
         lastNode = p->next;
   }
   listSize++;
}

template<class T>
void extendedChain<T>::push_back(const T& theElement)
{// Insert theElement at the end of the chain.
   chainNode<T>* newNode = new chainNode<T>(theElement, NULL);
   if (firstNode == NULL)
      // chain is empty
      firstNode = lastNode = newNode;
   else
   {  // attach next to lastNode
      lastNode->next = newNode;
      lastNode = newNode;
   }
   listSize++;
}
#endif

6.2circularListWithHeader类
//circularListWithHeader.h
#ifndef circularListWithHeader_
#define circularListWithHeader_

#include<iostream>
#include<sstream>
#include<string>
#include "chainNode.h"
#include "myExceptions.h"

using namespace std;

template<class T>
class circularListWithHeader 
{
   public:
      // constructor
      circularListWithHeader();

      // some methods
      int size() const {return listSize;}
      int indexOf(const T& theElement) const;
      void insert(int theIndex, const T& theElement);
      void output(ostream& out) const;

   protected:
      void checkIndex(int theIndex) const;
            // throw illegalIndex if theIndex invalid
      chainNode<T>* headerNode;  // pointer to header node
      int listSize;              // number of elements in list
};

#include<iostream>
#include<sstream>
#include<string>
#include "circularListWithHeader"
#include "chainNode.h"
#include "myExceptions.h"

using namespace std;

template<class T>
circularListWithHeader<T>::circularListWithHeader()
{// Constructor.
   headerNode = new chainNode<T>();
   headerNode->next = headerNode;
   listSize = 0;
}

template<class T>
void circularListWithHeader<T>::checkIndex(int theIndex) const
{// Verify that theIndex is between 0 and listSize - 1.
   if (theIndex < 0 || theIndex >= listSize)
   {ostringstream s;
    s << "index = " << theIndex << " size = " << listSize;
    throw illegalIndex(s.str());
   }

}

template<class T>
int circularListWithHeader<T>::indexOf(const T& theElement) const
{// Return index of first occurrence of theElement.
 // Return -1 if theElement not in list.

   // Put theElement in header node
   headerNode->element = theElement;

   // search the chain for theElement
   chainNode<T>* currentNode = headerNode->next;
   int index = 0;  // index of currentNode
   while (currentNode->element != theElement)
   {
      // move to next node
      currentNode = currentNode->next;
      index++;
   }

   // make sure we found matching element
   if (currentNode == headerNode)
      return -1;
   else
      return index;
}

template<class T>
void circularListWithHeader<T>::insert(int theIndex, const T& theElement)
{// Insert theElement so that its index is theIndex.
   if (theIndex < 0 || theIndex > listSize)
   {// invalid index
      ostringstream s;
      s << "index = " << theIndex << " size = " << listSize;
      throw illegalIndex(s.str());
   }

   // find predecessor of new element
   chainNode<T>* p = headerNode;
   for (int i = 0; i < theIndex; i++)
      p = p->next;
   
   // insert after p
   p->next = new chainNode<T>(theElement, p->next);
   
   listSize++;
}

template<class T>
void circularListWithHeader<T>::output(ostream& out) const
{// Put the list into the stream out.
   for (chainNode<T>* currentNode = headerNode->next;
                      currentNode != headerNode;
                      currentNode = currentNode->next)
      out << currentNode->element << "  ";
}

// overload <<
template <class T>
ostream& operator<<(ostream& out, const circularListWithHeader<T>& x)
   {x.output(out); return out;}

#endif

6.14
//结构studentRecord
#ifndef studentRecord_
#define studentRecord_

#include <string>

using namespace std;
struct studentRecord 
{
   int score;
   string* name;

   int operator !=(const studentRecord& x) const
      {return (score != x.score);}
};

ostream& operator<<(ostream& out, const studentRecord& x)
   {out << x.score << ' ' << *x.name << endl; return out;}

#endif

6.15
//结构studentRecord第二种定义
#ifndef studentRecord_
#define studentRecord_

#include <string>

using namespace std;

struct studentRecord 
{
   int score;
   string* name;

   operator int() const {return score;}
      // type conversion from studentRecord to int
};

ostream& operator<<(ostream& out, const studentRecord& x)
   {out << x.score << ' ' << *x.name << endl; return out;}

#endif

6.16
//结构studentRecord第三种定义
#ifndef studentRecord_
#define studentRecord_

#include <string>

using namespace std;

struct studentRecord 
{
   int score;
   string* name;

   int operator !=(const studentRecord& x) const
   {return (score != x.score ||);}

   operator int() const {return score;}
};

ostream& operator<<(ostream& out, const studentRecord& x)
   {out << x.score << ' ' << *x.name << endl; return out;}

#endif

6.18
void binSort(chain<studentRecord>& theChain, int range)
{// Sort by score.

   // initialize the bins
   chain<studentRecord> *bin;
   bin = new chain<studentRecord> [range + 1];

   // distribute student records from theChain to bins
   int numberOfElements = theChain.size();
   for (int i = 1; i <= numberOfElements; i++)
   {
      studentRecord x = theChain.get(0);
      theChain.erase(0);
      bin[x.score].insert(0,x);
   }

   // collect elements from bins
   for (int j = range; j >= 0; j--)
      while (!bin[j].empty())
      {
         studentRecord x = bin[j].get(0);
         bin[j].erase(0);
         theChain.insert(0,x);
      }

   delete [] bin;
}

6.20
//结构equivNode
#ifndef equivNode_
#define equivNode_

struct equivNode 
{
   int equivClass,  // element class identifier
       size,        // number of elements in class
       next;        // pointer to next element in class
};

#endif

6.21







数组和矩阵
7.1
//不规则二维数组创建和使用
#include<iostream>

using namespace std;

int main(void)
{
   int numberOfRows = 5;

   int length[5] = {6, 3, 4, 2, 7};

   int **irregularArray = new int* [numberOfRows];

   for (int i = 0; i < numberOfRows; i++)
      irregularArray[i] = new int [length[i]];

   irregularArray[2][3] = 5;
   irregularArray[4][6] = irregularArray[2][3] + 2;
   irregularArray[1][1] = 3;


   cout << irregularArray[2][3] << endl;
   cout << irregularArray[4][6] << endl;
   cout << irregularArray[1][1] << endl;

   return 0;
}

7.2
//矩阵类
//matrix.h
#ifndef matrix_
#define matrix_

#include "myExceptions.h"

using namespace std;
template<class T>
class matrix 
{
   friend ostream& operator<<(ostream&, const matrix<T>&);
   public:
      matrix(int theRows = 0, int theColumns = 0);
      matrix(const matrix<T>&);
      ~matrix() {delete [] element;}
      int rows() const {return theRows;}
      int columns() const {return theColumns;}
      T& operator()(int i, int j) const;
      matrix<T>& operator=(const matrix<T>&);
      matrix<T> operator+() const; // unary +
      matrix<T> operator+(const matrix<T>&) const;
      matrix<T> operator-() const; // unary minus
      matrix<T> operator-(const matrix<T>&) const;
      matrix<T> operator*(const matrix<T>&) const;
      matrix<T>& operator+=(const T&);
   private:
       int theRows,   
           theColumns; 
       T *element;     
};  

7.3~7.7
//matrix.cpp
template<class T>
matrix<T>::matrix(int theRows, int theColumns)
{
   if (theRows < 0 || theColumns < 0)
      throw illegalParameterValue("Rows and columns must be >= 0");
   if ((theRows == 0 || theColumns == 0)
                && (theRows != 0 || theColumns != 0))
      throw illegalParameterValue
      ("Either both or neither rows and columns should be zero");

   this->theColumns = theColumns;
   element = new T [theRows * theColumns];
}

template<class T>
matrix<T>::matrix(const matrix<T>& m)
{
   theRows = m.theRows;
   theColumns = m.theColumns;
   element = new T [theRows * theColumns];


   copy(m.element,
        m.element + theRows * theColumns,
        element);
}

template<class T>
matrix<T>& matrix<T>::operator=(const matrix<T>& m)
{
   if (this != &m)
   {
      delete [] element;
      theRows = m.theRows;
      theColumns = m.theColumns;
      element = new T [theRows * theColumns];
      copy(m.element,
           m.element + theRows * theColumns,
           element);
   }
   return *this;
}

template<class T>
T& matrix<T>::operator()(int i, int j) const
{
   if (i < 1 || i > theRows
       || j < 1 || j > theColumns)
   throw matrixIndexOutOfBounds();
   return element[(i - 1) * theColumns + j - 1];
}

template<class T>
matrix<T> matrix<T>::operator+(const matrix<T>& m) const
{
   if (theRows != m.theRows
       || theColumns != m.theColumns)
      throw matrixSizeMismatch();
      
   matrix<T> w(theRows, theColumns);
   for (int i = 0; i < theRows * theColumns; i++)
      w.element[i] = element[i] + m.element[i];

   return w;
}

template<class T>
matrix<T> matrix<T>::
          operator-(const matrix<T>& m) const
{
   if (theRows != m.theRows 
       || theColumns != m.theColumns)
      throw matrixSizeMismatch();

   matrix<T> w(theRows, theColumns);
   for (int i = 0; i < theRows * theColumns; i++)
      w.element[i] = element[i] - m.element[i];

   return w;
}

template<class T>
matrix<T> matrix<T>::operator-() const
{
 
   matrix<T> w(theRows, theColumns);
   for (int i = 0; i < theRows * theColumns; i++)
      w.element[i] = -element[i];
   return w;

}

template<class T>
matrix<T> matrix<T>::operator*(const matrix<T>& m) const
{
   if (theColumns != m.theRows) 
      throw matrixSizeMismatch();

   matrix<T> w(theRows, m.theColumns);  // result matrix


   int ct = 0, cm = 0, cw = 0;

 
   for (int i = 1; i <= theRows; i++)
   {
      for (int j = 1; j <= m.theColumns; j++)
      {
          T sum =  element[ct] * m.element[cm];

          // add in remaining terms
          for (int k = 2; k <= theColumns; k++)
          {
             ct++;  // next term in row i of *this
             cm += m.theColumns;  // next in column j of m
             sum += element[ct] * m.element[cm];
          }
          w.element[cw++] = sum;  // save w(i,j)
 
          // reset to start of row and next column
          ct -= theColumns - 1;
          cm = j;
      }

      // reset to start of next row and first column
      ct += theColumns;
      cm = 0;
   }

   return w;
}

template<class T>
matrix<T>& matrix<T>::operator+=(const T& x)
{
   for (int i = 0; i < theRows * theColumns; i++)
       element[i] += x;
   return *this;
}

template<class T>
ostream& operator<<(ostream& out, const matrix<T>& m)
{
   int k = 0;  // index into element array
   for (int i = 0; i < m.theRows; i++)
   {
      for (int j = 0; j < m.theColumns; j++)
         out << m.element[k++] << "  ";

      out << endl;
   }

   return out;
}

// for some reason compiler can't create this on its own
ostream& operator<<(ostream& out, const matrix<int>& m)
{// Put matrix m into the stream out.
 // One row per line.
   int k = 0;  // index into element array
   for (int i = 0; i < m.theRows; i++)
   {// do row i
      for (int j = 0; j < m.theColumns; j++)
         out << m.element[k++] << "  ";

      // row i finished
      out << endl;
   }

   return out;
}

#endif



















7-8
.cpp
int main(void)
{
   diagonalMatrix<int> x(20);
   x.set(1,1,22);
   x.set(5,5,44);
   x.set(8,5,0);
   cout << x.get(5,5) << endl;
   cout << x.get(1,1) << endl;
   cout << x.get(10,1) << endl;
   
   return 0;
}
.h
#ifndef diagonalMatrix_
#define diagonalMatrix_


#include "myExceptions.h"

using namespace std;

template<class T>
class diagonalMatrix 
{
   public:
      diagonalMatrix(int theN = 10);
      ~diagonalMatrix() {delete [] element;}
      T get(int, int) const;
      void set(int, int, const T&);
   private:
      int n;       // matrix dimension
      T *element;  // 1D array for diagonal elements
};

template<class T>
diagonalMatrix<T>::diagonalMatrix(int theN)
{// Constructor.
   // validate theN
   if (theN < 1)
       throw illegalParameterValue("Matrix size must be > 0");

   n = theN;
   element = new T [n];
}
  
template <class T>
T diagonalMatrix<T>::get(int i, int j) const
{// Return (i,j)th element of matrix.
   // validate i and j
   if (i < 1 || j < 1 || i > n || j > n)
       throw matrixIndexOutOfBounds();

   if (i == j)
      return element[i-1];   // diagonal element
   else
      return 0;              // nondiagonal element
}

template<class T>
void diagonalMatrix<T>::set(int i, int j, const T& newValue)
{// Store newValue as (i,j)th element.
   // validate i and j
   if (i < 1 || j < 1 || i > n || j > n)
       throw matrixIndexOutOfBounds();

   if (i == j)
     // save the diagonal value
      element[i-1] = newValue;
   else
      // nondiagonal value, newValue must be zero
      if (newValue != 0)
         throw illegalParameterValue
               ("nondiagonal elements must be zero");
}

#endif

7-12
.cpp

#include <iostream>
#include "lowerTriangularMatrix.h"

using namespace std;

int main(void)
{
   lowerTriangularMatrix<int> x(20);
   x.set(1,1,22);
   x.set(5,3,44);
   x.set(8,5,0);
   x.set(10,2,55);
   x.set(8,5,0);
   cout << x.get(10,2) << endl;
   cout << x.get(5,3) << endl;
   cout << x.get(1,1) << endl;
   cout << x.get(10,14) << endl;
   cout << x.get(8,5) << endl;

   return 0;
}

.h
// lower triangle matrix
#ifndef lowerTriangularMatrix_
#define lowerTriangularMatrix_


#include "myExceptions.h"

using namespace std;

template<class T>
class lowerTriangularMatrix 
{
   public:
      lowerTriangularMatrix(int theN = 10);
      ~lowerTriangularMatrix() {delete [] element;}
      T get(int, int) const;
      void set(int, int, const T&);
   private:
      int n;       // matrix dimension
      T *element;  // 1D array for lower triangle
};


template<class T>
lowerTriangularMatrix<T>::lowerTriangularMatrix(int theN)
{// Constructor.
   // validate then
   if (theN < 1)
       throw illegalParameterValue("Matrix size must be > 0");

   n = theN;
   element = new T [n * (n + 1) / 2];
}
   
template <class T>
T lowerTriangularMatrix<T>::get(int i, int j) const
{// Return (i,j)th element of matrix.
   // validate i and j
   if ( i < 1 || j < 1 || i > n || j > n)
       throw matrixIndexOutOfBounds();

   // (i,j) in lower triangle iff i >= j
   if (i >= j)
      return element[i * (i - 1) / 2 + j - 1];
   else
      return 0;
}

template<class T>
void lowerTriangularMatrix<T>::set(int i, int j, const T& newValue)
{// Store newValue as (i,j)th element.
   // validate i and j
   if ( i < 1 || j < 1 || i > n || j > n)
       throw matrixIndexOutOfBounds();


   // (i,j) in lower triangle iff i >= j
   if (i >= j)
      element[i * (i - 1) / 2 + j - 1] = newValue;
   else
      if (newValue != 0)
         throw illegalParameterValue
               ("elements not in lower triangle must be zero");
}

#endif
7-13
Mian
#include <iostream>
#include "sparseMatrix.h"

int main(void)
{
   sparseMatrix<int> a, b, c;

   // test input and output
   cin >> a;
   cout << "Matrix a is" << endl << a;
   cin >> b;
   cout << "Matrix b is" << endl << b;

   // test transpose
   a.transpose(c);
   cout << "The transpose of a is" << endl << c;

   // test add
   a.add(b,c);
   cout << "The sum of a and b is" << endl << c;

   return 0;
}
.cpp// sparse matrix using an extended array list

#ifndef sparseMatrix_
#define sparseMatrix_

#include <iostream>
#include "matrixTerm.h"
#include "extendedArrayList.h"
#include "myExceptions.h"

template<class T>
class sparseMatrix
{
   friend ostream& operator<<
          (ostream&, sparseMatrix<T>&);
   friend istream& operator>>
          (istream&, sparseMatrix<T>&);
   public:
      void transpose(sparseMatrix<T> &b);
      void add(sparseMatrix<T> &b, sparseMatrix<T> &c);
   private:
      int rows,    // number of rows in matrix
          cols;    // number of columns in matrix
      arrayList<matrixTerm<T> > terms;
                   // list of nonzero terms
};

// overload <<
template <class T>
ostream& operator<<(ostream& out, sparseMatrix<T>& x)
{// Put x in output stream.

   // put matrix characteristics
   out << "rows = " << x.rows << " columns = "
       << x.cols  << endl;
   out << "nonzero terms = " << x.terms.size() << endl;

   // put terms, one per line
   for (arrayList<matrixTerm<T> >::iterator i = x.terms.begin();
        i != x.terms.end(); i++)
      out << "a(" << (*i).row << ',' << (*i).col
          << ") = " << (*i).value << endl;

   return out;
}

// overload >>
template<class T>
istream& operator>>(istream& in, sparseMatrix<T>& x)
{// Input a sparse matrix.

   // input matrix characteristics
   int numberOfTerms;
   cout << "Enter number of rows, columns, and #terms"
        << endl;
   in >> x.rows >> x.cols >> numberOfTerms;

   // set size of x.terms and ensure enough capacity
   x.terms.reSet(numberOfTerms);

   // input terms
   matrixTerm<T> mTerm;
   for (int i = 0; i < numberOfTerms; i++)
   {
      cout << "Enter row, column, and value of term " 
           << (i + 1) << endl;
      in >> mTerm.row >> mTerm.col >> mTerm.value;
      x.terms.set(i, mTerm);
   }

   return in;
}


/****************************************************************/
// explict code tooverload with T = int for test as compiler
// unable to generate

// overload <<
ostream& operator<<(ostream& out, sparseMatrix<int>& x)
{// Put x in output stream.

   // put matrix characteristics
   out << "rows = " << x.rows << " columns = "
       << x.cols  << endl;
   out << "nonzero terms = " << x.terms.size() << endl;

   // put terms, one per line
   for (arrayList<matrixTerm<int> >::iterator i = x.terms.begin();
        i != x.terms.end(); i++)
      out << "a(" << (*i).row << ',' << (*i).col
          << ") = " << (*i).value << endl;

   return out;
}

// overload >>
istream& operator>>(istream& in, sparseMatrix<int>& x)
{// Input a sparse matrix.

   // input matrix characteristics
   int numberOfTerms;
   cout << "Enter number of rows, columns, and #terms"
        << endl;
   in >> x.rows >> x.cols >> numberOfTerms;

   // set size of x.terms and ensure enough capacity
   x.terms.reSet(numberOfTerms);

   // input terms
   matrixTerm<int> mTerm;
   for (int i = 0; i < numberOfTerms; i++)
   {
      cout << "Enter row, column, and value of term " 
           << (i + 1) << endl;
      in >> mTerm.row >> mTerm.col >> mTerm.value;
      x.terms.set(i, mTerm);
   }

   return in;
}
/****************************************************************/
template<class T>
void sparseMatrix<T>::transpose(sparseMatrix<T> &b)
{// Return transpose of *this in b.

   // set transpose characteristics
   b.cols = rows;
   b.rows = cols;
   b.terms.reSet(terms.size());

   // initialize to compute transpose
   int* colSize = new int[cols + 1];
   int* rowNext = new int[cols + 1];
   
   // find number of entries in each column of *this
   for (int i = 1; i <= cols; i++) // initialize
      colSize[i] = 0;  
   for (arrayList<matrixTerm<T> >::iterator i = terms.begin();
        i != terms.end(); i++)
      colSize[(*i).col]++;  
   
   // find the starting point of each row of b
   rowNext[1] = 0;
   for (int i = 2; i <= cols; i++)
      rowNext[i] = rowNext[i - 1] + colSize[i - 1];  
   
   // perform the transpose copying from *this to b
   matrixTerm<T> mTerm;
   for (arrayList<matrixTerm<T> >::iterator i = terms.begin();
        i != terms.end(); i++)
   {
      int j = rowNext[(*i).col]++; // position in b
      mTerm.row = (*i).col;
      mTerm.col = (*i).row;
      mTerm.value = (*i).value;
      b.terms.set(j, mTerm);
   }
}

template<class T>
void sparseMatrix<T>::add(sparseMatrix<T> &b, sparseMatrix<T> &c)
{// Compute c = (*this) + b.

   // verify compatibility
   if (rows != b.rows || cols != b.cols)
     throw matrixSizeMismatch(); // incompatible matrices

   // set characteristics of result c
   c.rows = rows;
   c.cols = cols;
   c.terms.clear();
   int cSize = 0;

   // define iterators for *this and b
   arrayList<matrixTerm<T> >::iterator it = terms.begin();
   arrayList<matrixTerm<T> >::iterator ib = b.terms.begin();
   arrayList<matrixTerm<T> >::iterator itEnd = terms.end();
   arrayList<matrixTerm<T> >::iterator ibEnd = b.terms.end();

   // move through *this and b adding like terms
   while (it != itEnd && ib != ibEnd)
   {
     // row-major index plus cols of each term
     int tIndex = (*it).row * cols + (*it).col;
     int bIndex = (*ib).row * cols + (*ib).col;

     if (tIndex < bIndex)
     {// b term comes later
   	 c.terms.insert(cSize++, *it);
         it++;
     }
     else {if (tIndex == bIndex)
           {// both in same position

              // append to c only if sum not zero
              if ((*it).value + (*ib).value != 0)
              {
                 matrixTerm<T> mTerm;
                 mTerm.row = (*it).row;
                 mTerm.col = (*it).col;
                 mTerm.value = (*it).value + (*ib).value;
                 c.terms.insert(cSize++, mTerm);
              }

              it++; 
              ib++;
           }
           else
           {// a term comes later
              c.terms.insert(cSize++, *ib);
              ib++;
           }
          }
     }

   // copy over remaining terms
   for (; it != itEnd; it++)
      c.terms.insert(cSize++, *it);
   for (; ib != ibEnd; ib++)
      c.terms.insert(cSize++, *ib);
}

#endif
8-4
.h
// array implementation of a stack
// derives from the ADT stack

#ifndef arrayStack_
#define arrayStack_

#include "stack.h"
#include "myExceptions.h"
#include "changeLength1D.h"
#include <sstream>


template<class T>
class arrayStack : public stack<T>
{
   public:
      arrayStack(int initialCapacity = 10);
      ~arrayStack() {delete [] stack;}
      bool empty() const {return stackTop == -1;}
      int size() const
          {return stackTop + 1;}
      T& top()
         {
            if (stackTop == -1)
               throw stackEmpty();
            return stack[stackTop];
         }
      void pop()
           {
              if (stackTop == -1)
                 throw stackEmpty();
              stack[stackTop--].~T();  // destructor for T
           }
      void push(const T& theElement);
   private:
      int stackTop;         // current top of stack
      int arrayLength;      // stack capacity
      T *stack;           // element array
};

template<class T>
arrayStack<T>::arrayStack(int initialCapacity)
{// Constructor.
   if (initialCapacity < 1)
   {ostringstream s;
    s << "Initial capacity = " << initialCapacity << " Must be > 0";
    throw illegalParameterValue(s.str());
   }
   arrayLength = initialCapacity;
   stack = new T[arrayLength];
   stackTop = -1;
}

template<class T>
void arrayStack<T>::push(const T& theElement)
{// Add theElement to stack.
   if (stackTop == arrayLength - 1)
      {// no space, double capacity
         changeLength1D(stack, arrayLength, 2 * arrayLength);
         arrayLength *= 2;
      }

   // add at stack top
   stack[++stackTop] = theElement;
}
#endif
Main

// test array stack

#include <iostream>
#include "arrayStack.h"
#include "myExceptions.h"

using namespace std;

int main(void)
{
   arrayStack<int> s;

   // add a few elements
   s.push(1);
   s.push(2);
   s.push(3);
   s.push(4);

   cout << "Stack should be 1234, bottom to top" << endl;

   // test empty and size
   if (s.empty())
      cout << "The stack is empty" << endl;
   else
      cout << "The stack is not empty" << endl;

   cout << "The stack size is " << s.size() << endl;

   while (!s.empty())
   {
      cout << "Stack top is " << s.top() << endl;
      s.pop();
      cout << "Popped top element" << endl;
   }

   try {s.pop();}
   catch (stackEmpty message)
   {
      cout << "Last pop failed " << endl;
      message.outputMessage();
   }

   return 0;
}
8-10.cpp
// railroad car rearrangement using no explicit queues
#include <iostream>

using namespace std;

// global variables
int* whichTrack;  // track that has the car
int* lastCar;     // last car in track
int numberOfCars;
int numberOfTracks;

void outputFromHoldingTrack(int c)
{// Move car c from its holding track to the output track.
   cout << "Move car " << c << " from holding track "
        << whichTrack[c] << " to output track" << endl;

   // if c was the last car in its track, the track is now empty
   if (c == lastCar[whichTrack[c]])
      lastCar[whichTrack[c]] = 0;
}


bool putInHoldingTrack(int c)
{// Put car c into a holding track.
 // Return false iff there is no feasible holding track for this car.

   // find best holding track for car c
   // initialize
   int bestTrack = 0,  // best track so far
       bestLast =  0;  // last car in bestTrack

   // scan tracks
   for (int i = 1; i <= numberOfTracks; i++)
      if (lastCar[i] != 0)
      {// track i not empty
          if (c > lastCar[i] && lastCar[i] > bestLast)
          {
             // track i has bigger car at its rear
             bestLast = lastCar[i];
             bestTrack = i;
          }
      }
      else // track i empty
         if (bestTrack == 0)
            bestTrack = i;
      
   if (bestTrack == 0)
      return false; // no feasible track

   // add c to bestTrack
   whichTrack[c] = bestTrack;
   lastCar[bestTrack] = c;
   cout << "Move car " << c << " from input track "
        << "to holding track " << bestTrack << endl;

   return true;
}

bool railroad(int* inputOrder,
              int theNumberOfCars, int theNumberOfTracks)
{// Rearrange railroad cars beginning with the initial order.
 // inputOrder[1:theNumberOfCars]
 // Return true if successful, false if impossible.

   numberOfCars = theNumberOfCars;
   // keep last track open for output
   numberOfTracks = theNumberOfTracks - 1;

   // create the arrays lastCar and whichTrack
   lastCar = new int [numberOfTracks + 1];
   fill(lastCar + 1, lastCar + numberOfTracks + 1, 0);
   whichTrack = new int [numberOfCars + 1];
   fill(whichTrack + 1, whichTrack + numberOfCars + 1, 0);

   int nextCarToOutput = 1;

   // rearrange cars
   for (int i = 1; i <= numberOfCars; i++)
      if (inputOrder[i] == nextCarToOutput)
      {// send car inputOrder[i] straight out
          cout << "Move car " << inputOrder[i] << " from input "
               << "track to output track" << endl;
          nextCarToOutput++;
 
          // output from holding tracks
          while (nextCarToOutput <= numberOfCars &&
                 whichTrack[nextCarToOutput] != 0)
          {
             outputFromHoldingTrack(nextCarToOutput);
    	     nextCarToOutput++;
         }
      }
      else
      // put car inputOrder[i] in a holding track
         if (!putInHoldingTrack(inputOrder[i]))
            return false;

   return true;
}

int main()
{
   //int p[] = {0, 5, 8, 1, 7, 4, 2, 9, 6, 3};
   //cout << "Input permutation is 581742963" << endl;
   int p[] = {0, 3, 6, 9, 2, 4, 7, 1, 8, 5};
   cout << "Input permutation is 369247185" << endl;
   railroad(p, 9, 3);

   return 0;
}


